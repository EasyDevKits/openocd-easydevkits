# SPDX-License-Identifier: GPL-2.0-or-later
# 

# Source the ESP common configuration file
source [find target/esp_common.cfg]

# Target specific registers
set EFUSE_MAC_ADDR_REG  0x600B0844

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME esp32h2
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x00010c25
}

set _TARGETNAME $_CHIPNAME
set _CPUNAME cpu
set _TAPNAME $_CHIPNAME.$_CPUNAME

jtag newtap $_CHIPNAME $_CPUNAME -irlen 5 -expected-id $_CPUTAPID

proc esp32h2_wdt_disable { } {
    # Halt event can occur during config phase (before "init" is done).
    # Ignore it since mww commands don't work at that time.
    if { [string compare [command mode] config] == 0 } {
        return
    }

    # Timer Group 0 & 1 WDTs
    mww 0x60009064 0x50D83AA1
    mww 0x60009048 0
    mww 0x6000A064 0x50D83AA1
    mww 0x6000A048 0
    # WDT_RTC
    #mww 0x600b1c18 0x50D83AA1
    #mww 0x600B1C00 0
    # WDT_SWD
    #mww 0x600b1c20 0x8F1D312A
    #mww 0x600b1c1c 0x84B00000
}
set _ESP_WDT_DISABLE esp32h2_wdt_disable

proc esp32h2_soc_reset { } {
    riscv dmi_write 0x10 0x80000001
    riscv dmi_write 0x38 0x48000
    riscv dmi_write 0x39 0x600b1034
    riscv dmi_write 0x3C 0x80000000
    # clear dmactive to clear sbbusy otherwise debug module gets stuck
    riscv dmi_write 0x10 0

    riscv dmi_write 0x38 0x48000
    riscv dmi_write 0x39 0x600b1038
    riscv dmi_write 0x3C 0x10000000

    # clear dmactive to clear sbbusy otherwise debug module gets stuck
    riscv dmi_write 0x10 0
    riscv dmi_write 0x10 0x40000001
    # Here debugger reads dmstatus as 0xc03a2

    # Wait for the reset to happen
    sleep 10
    poll
    # Here debugger reads dmstatus as 0x3a2

    # Disable the watchdogs again
    esp32h2_wdt_disable

    # Here debugger reads anyhalted and allhalted bits as set (0x3a2)
    # We will clean allhalted state by resuming the core.
    riscv dmi_write 0x10 0x40000001

    # Put the hart back into reset state. Note that we need to keep haltreq set.
    riscv dmi_write 0x10 0x80000003
}
set _ESP_SOC_RESET esp32h2_soc_reset

proc esp32h2_memprot_is_enabled { } {
    # TODO
    return 0
}
set _ESP_MEMPROT_IS_ENABLED esp32h2_memprot_is_enabled

if { $_RTOS == "none" } {
    target create $_TARGETNAME esp32h2 -chain-position $_TAPNAME
} else {
    target create $_TARGETNAME esp32h2 -chain-position $_TAPNAME -rtos $_RTOS
}

# stub flasher may need a lot of memory in case of compressed writes to flash (~107KB):
# - for apptrace: 2x16KB up buffers + 32KB down buffer
# - for uncompression: 32KB for unzip buffer size + 11KB for inflator data structs
# TODO: In general when up buffers are swapped apptrace copies `host->target` data from new up buffer to down buffer to free space for `target->host` data.
# In case of flash writes we use apptrace transfers in one direction only. So we can avoid copying and re-use up buffer instead of down one.
configure_esp_workarea $_TARGETNAME 0x40800000 0x4000 0x40804000 0x20000
configure_esp_flash_bank $_TARGETNAME $_TARGETNAME $_FLASH_SIZE

configure_esp_riscv_events
configure_esp_riscv_default_settings
