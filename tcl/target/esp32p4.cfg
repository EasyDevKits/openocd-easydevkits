# SPDX-License-Identifier: GPL-2.0-or-later
#

# Source the ESP common configuration file.
source [find target/esp_common.cfg]

# Target specific global variables
set _CHIPNAME                   "esp32p4"
set _CHIP_LP_NAME               $_CHIPNAME.lp
set _CHIP_HP_NAME               $_CHIPNAME.hp
set _CPUTAPID                   0x0012c25
set _ESP_ARCH                   "riscv"
set _LP_TAPNUM                  1
set _HP_TAPNUM                  1
set _ESP_SMP_TARGET             1
set _ESP_EFUSE_MAC_ADDR_REG     0x5012D044
set _RTOS                       "FreeRTOS"

# If not set until now, set as default dual core.
# When LP core debug is enabled for P4, _ONLYCPU can be set in LP core config file
if { ![info exists _ONLYCPU] } {
	set _ONLYCPU 0x03
}

if { $_ONLYCPU == 0x1 } {
	set _ESP_SMP_TARGET 0
}

# Set workarea address and size
# stub flasher may need a lot of memory in case of compressed writes to flash (~107KB):
# - for apptrace: 2x16KB up buffers + 32KB down buffer
# - for uncompression: 32KB for unzip buffer size + 11KB for inflator data structs
set _WA_ADDR                    0x8FF00000
set _WA_SIZE                    0x24000

proc esp32p4_wdt_disable { } {
	# Halt event can occur during config phase (before "init" is done).
	# Ignore it since mww commands don't work at that time.
	if { [string compare [command mode] config] == 0 } {
		return
	}

	# Disable TG0 watchdog
	mww 0x500c2064 0x50D83AA1
	mww 0x500c2048 0
	# Clear TG0 wdt interrupt state
	mww 0x500c207c 0x4

	# Disable TG1 watchdog
	mww 0x500c3064 0x50D83AA1
	mww 0x500c3048 0
	# Clear TG1 wdt interrupt state
	mww 0x500c307c 0x4

	# Disable RTC watchdog
	mww 0x50116018 0x50D83AA1
	mww 0x50116000 0
	# Clear RTC wdt interrupt state
	mww 0x50116030 0xC0000000
}

proc esp32p4_cpu0_wdt_disable { } {
	global _RISCV_DMCONTROL

	# Select hart0
	riscv dmi_write $_RISCV_DMCONTROL       0x80000001
	esp32p4_wdt_disable
}

proc esp32p4_soc_reset { } {
	global _RISCV_DMCONTROL _RISCV_SB_CS _RISCV_SB_ADDR0 _RISCV_SB_DATA0

	riscv dmi_write $_RISCV_DMCONTROL       0x80000001
	riscv dmi_write $_RISCV_SB_CS           0x40000
	# Writing LP_SYS_SYS_CTRL_REG causes the System Reset
	# System Reset: resets the whole digital system, including the LP system.
	riscv dmi_write $_RISCV_SB_ADDR0        0x50110008
	# Set (LP_SYS_SYS_SW_RST|LP_SYS_DIG_FIB|LP_SYS_ANA_FIB|LP_SYS_LP_FIB_SEL)
	riscv dmi_write $_RISCV_SB_DATA0        0x1fffc7fa

	# Wait for the reset to happen
	sleep 10
	poll

	esp32p4_cpu0_wdt_disable

	# Here debugger reads anyhalted and allhalted bits as set (0x3a2)
	# We will clean allhalted state by resuming the core.
	riscv dmi_write $_RISCV_DMCONTROL       0x40000001

	# Put the hart back into reset state. Note that we need to keep haltreq set.
	riscv dmi_write $_RISCV_DMCONTROL       0x80000003
}

proc esp32p4_memprot_is_enabled { } {
	global _RISCV_ABS_CMD _RISCV_ABS_DATA0

	# If IRAM/DRAM split is enabled 2 TOR match mode address ranges are used.
	# If IRAM/DRAM split is disabled 1 TOR address range is used.
	# In order to determine if the IRAM/DRAM regions are protected against RWX/RW,
	# it is necessary to first read the mode and then apply the appropriate method for checking.
	# We can understand the mode reading pmp5cfg in pmpcfg1 register.
	# If it is none we know only one range is used.

	# Read pmpcfg0 and pmpcfg1 and extract into 8-bit variables.
	riscv dmi_write $_RISCV_ABS_CMD 0x2203a0
	set pmpcfg0 [riscv dmi_read $_RISCV_ABS_DATA0]
	riscv dmi_write $_RISCV_ABS_CMD 0x2203a1
	set pmpcfg1 [riscv dmi_read $_RISCV_ABS_DATA0]

	set pmp3cfg [expr {($pmpcfg0 >> (8 * 3)) & 0xFF}]
	set pmp4cfg [expr {($pmpcfg1 >> (8 * 0)) & 0xFF}]
	set pmp5cfg [expr {($pmpcfg1 >> (8 * 1)) & 0xFF}]

	set IRAM_LOW    0x4FF00000
	set IRAM_HIGH   0x4FFC0000
	set DRAM_LOW    0x4FF00000
	set DRAM_HIGH   0x4FFC0000
	set PMP_RWX     0x07
	set PMP_RW      0x03
	set PMP_A       [expr {($pmp5cfg >> 3) & 0x03}]

	if {$PMP_A == 1} {
		# IRAM/DRAM split is enabled.

		# Read PMPADDR 3-5
		riscv dmi_write $_RISCV_ABS_CMD 0x2203b3
		set pmpaddr3 [expr {[riscv dmi_read $_RISCV_ABS_DATA0] << 2}]
		riscv dmi_write $_RISCV_ABS_CMD 0x2203b4
		set pmpaddr4 [expr {[riscv dmi_read $_RISCV_ABS_DATA0] << 2}]
		riscv dmi_write $_RISCV_ABS_CMD 0x2203b5
		set pmpaddr5 [expr {[riscv dmi_read $_RISCV_ABS_DATA0] << 2}]

		# The lock bit remains unset during the execution of the 2nd stage bootloader.
		# Thus we do not perform a lock bit check for IRAM and DRAM regions.

		# Check OpenOCD can write and execute from IRAM.
		if {$pmpaddr3 >= $IRAM_LOW && $pmpaddr4 <= $IRAM_HIGH} {
			if {($pmp3cfg & $PMP_RWX) != 0 || ($pmp4cfg & $PMP_RWX) != $PMP_RWX} {
				return 1
			}
		}

		# Check OpenOCD can read/write  entire DRAM region.
		if {$pmpaddr5 >= $DRAM_LOW && $pmpaddr3 <= $DRAM_HIGH} {
			if {($pmp3cfg & $PMP_RW) != $PMP_RW} {
				return 1
			}
		}
	} elseif {$PMP_A == 0} {
		# IRAM/DRAM split is disabled.

		# Read PMPADDR 3-4
		riscv dmi_write $_RISCV_ABS_CMD 0x2203b3
		set pmpaddr3 [expr {[riscv dmi_read $_RISCV_ABS_DATA0] << 2}]
		riscv dmi_write $_RISCV_ABS_CMD 0x2203b4
		set pmpaddr4 [expr {[riscv dmi_read $_RISCV_ABS_DATA0] << 2}]

		# Check OpenOCD can read/write  entire DRAM region.
		if {$pmpaddr4 >= $DRAM_LOW && $pmpaddr3 <= $DRAM_HIGH} {
			if {($pmp3cfg & $PMP_RWX) != $PMP_RWX} {
				return 1
			}
		}
	}

	return 0
}

proc create_esp32p4_jtag { } {
	global _CHIP_LP_NAME _CHIP_HP_NAME _CPUNAME _CPUTAPID
	jtag newtap $_CHIP_LP_NAME $_CPUNAME -irlen 5 -expected-id $_CPUTAPID
	jtag newtap $_CHIP_HP_NAME $_CPUNAME -irlen 5 -expected-id $_CPUTAPID
}

create_esp_target $_ESP_ARCH

foreach tgt [target names] {
	$tgt riscv expose_csrs 848=mclicbase
	$tgt riscv expose_csrs 1984=mxstatus
	$tgt riscv expose_csrs 1985=mhcr
	$tgt riscv expose_csrs 1989=mhint
	$tgt riscv expose_csrs 2016=mraddr
	$tgt riscv expose_csrs 2017=mexstatus
	$tgt riscv expose_csrs 2018=mnmicause
	$tgt riscv expose_csrs 2019=mnmipc
	$tgt riscv expose_csrs 2020=cpu_testbus_ctrl
	$tgt riscv expose_csrs 2051=gpio_oen_user
	$tgt riscv expose_csrs 2052=gpio_in_user
	$tgt riscv expose_csrs 2053=gpio_out_user
	$tgt riscv expose_csrs 2064=pm_user
	$tgt riscv expose_csrs 3008=pma_cfg0
	$tgt riscv expose_csrs 3009=pma_cfg1
	$tgt riscv expose_csrs 3010=pma_cfg2
	$tgt riscv expose_csrs 3011=pma_cfg3
	$tgt riscv expose_csrs 3012=pma_cfg4
	$tgt riscv expose_csrs 3013=pma_cfg5
	$tgt riscv expose_csrs 3014=pma_cfg6
	$tgt riscv expose_csrs 3015=pma_cfg7
	$tgt riscv expose_csrs 3016=pma_cfg8
	$tgt riscv expose_csrs 3017=pma_cfg9
	$tgt riscv expose_csrs 3018=pma_cfg10
	$tgt riscv expose_csrs 3019=pma_cfg11
	$tgt riscv expose_csrs 3020=pma_cfg12
	$tgt riscv expose_csrs 3021=pma_cfg13
	$tgt riscv expose_csrs 3022=pma_cfg14
	$tgt riscv expose_csrs 3023=pma_cfg15
	$tgt riscv expose_csrs 3024=pma_addr0
	$tgt riscv expose_csrs 3025=pma_addr1
	$tgt riscv expose_csrs 3026=pma_addr2
	$tgt riscv expose_csrs 3027=pma_addr3
	$tgt riscv expose_csrs 3028=pma_addr4
	$tgt riscv expose_csrs 3029=pma_addr5
	$tgt riscv expose_csrs 3030=pma_addr6
	$tgt riscv expose_csrs 3031=pma_addr7
	$tgt riscv expose_csrs 3032=pma_addr8
	$tgt riscv expose_csrs 3033=pma_addr9
	$tgt riscv expose_csrs 3034=pma_addr10
	$tgt riscv expose_csrs 3035=pma_addr11
	$tgt riscv expose_csrs 3036=pma_addr12
	$tgt riscv expose_csrs 3037=pma_addr13
	$tgt riscv expose_csrs 3038=pma_addr14
	$tgt riscv expose_csrs 3039=pma_addr15
}
